var fs = require("fs");
var Variables = require("../../lib/variable");
var backtrack = require("../../lib/backtrack");

function getJSON (filename) {
	var template = JSON.parse(fs.readFileSync(filename));
	return template;
};

/* ===============
 * 	  Gen grid
 * 
 * - Note: Solution items order doesnt matter since random solutions 
 *   can be generated by item replacement.
 * ===============
 */
function genGrid (cols, lines, prefix) {
	prefix = prefix || "tvar";
	
	var r = {
		solution: [],
		posy: {},
		w: cols,
		h: lines
	};
	
	for (var y=0; y<lines; y++) {
		var vars = [];
		var domain = [];
		var strVars = [];
		for (var x=0; x<cols; x++) {
			var id = prefix + y+ "_" +x;
			domain.push(id);
			r.posy[id] = y;
		}
		r.solution.push (domain);
	}
	
	r.constrains = getConstrains(r);
	
	return r;
};

/* ===============
 * 		Get all possible constrains
 * 
 * - Returns a list of all possible constrains that can be applyed to grid.
 * ===============
 */
function getConstrains (grid) {
	var constrains = [];
	var solution = grid.solution;
	
	function getVar (yA, vA) {
		return {
			y: yA,
			v: vA
		};
	};
	
	function getClue (typeA, a, b) {
		var clue = {
			type: typeA,
			a: a,
		};
		
		if (b) {clue.b = b;}
		
		return clue;
	};

	// Gen "item" clues,
	for (var y=0; y<grid.h; y++) {
		for (var x=1; x < grid.w; x++) {
			var a = getVar(y, solution[y][x]);
			constrains.push(getClue("item", a));
		}
	}
	
	// Gen "middle" clues,
	for (var y=0; y<grid.h; y++) {
		for (var x=1; x < grid.w-1; x++) {
			var a = getVar(y, solution[y][x]);
			constrains.push(getClue("middle", a));
		}
	}
	
	// Gen "immediately to the left of" and "next to" clues,
	for (var x=0; x < grid.w-1; x++) {
		for (var y=0; y<grid.h; y++) {
			for (var y2=0; y2<grid.h; y2++) {
				// immediately to the left of,
				var a = getVar(y, solution[y][x]);
				var b = getVar(y2, solution[y2][x+1]);
				var clue = getClue("immediately to the left of", a, b);
				constrains.push(clue);
				
				// next to,
				var a = getVar(y, solution[y][x]);
				var b = getVar(y2, solution[y2][x+1]);
				var clue = getClue("next to", a, b);
				
				constrains.push(clue);
			}
		}
	}

	// Gen "same position as" clues,
	for (var x=0; x < grid.w; x++) {
		for (var y=0; y<grid.h; y++) {
			for (var y2=y+1; y2<grid.h; y2++) {
				var a = getVar(y, solution[y][x]);
				var b = getVar(y2, solution[y2][x]);
				var clue = getClue("same position as", a, b);
				
				constrains.push(clue);
			}
		}
	}
	
	return constrains;
};

function getSaveClues (grid) {
	var filename = "templates/template-"+ grid.w + "x" + grid.h + ".json";
	console.log("Puzzles are going to be saved to " + filename);
	var solutions = [];

	try {
		solutions = JSON.parse(fs.readFileSync (filename)).solutions; // , function (err, data) {
	}
	catch (e) {
		solutions = [];
	}

	return function (clues) {
		var r = [];
		
		clues.forEach (function (clue) {
			if (clue.b) {
				r.push({
					type: clue.type,
					a: {
						v: clue.a.v,
						y: clue.a.y
					},
					b: {
						v: clue.b.v,
						y: clue.b.y
					}
				});
			}
			else {
				r.push({
					type: clue.type,
					a: {
						v: clue.a.v,
						y: clue.a.y
					}
				});
			}
		});
		
		
		solutions.push(r);
		console.log("Save Solution: " + solutions.length);
		console.log(JSON.stringify(r));

		var w = {
			grid: {
				w: grid.w,
				h: grid.h
			},
			solutions: solutions
		};
		
		fs.writeFileSync(filename, JSON.stringify(w));
	};

};

var constrains = {
	"item": function (v, grid, a) {
		var domain = [];
		for (var i=0; i<grid.w; i++) {
			domain.push(i);
		}

		a.x = v({domain:domain});
	},
	"next to": function (v, grid, a, b) {
		var domain = [];
		for (var i=0; i<grid.w; i++) {
			domain.push(i);
		}
	
		a.x = v({domain:domain});
		b.x = v({domain:domain});
		
		b.x.ondomain (function (a) {
			return function (b) {
				var da = a.getValues();
				var db = b.getValues();
				var ok = true;
				
				da.forEach (function (x) {
					if (
						(db.indexOf(x+1) === -1)
						&& (db.indexOf(x-1) === -1)
					) {
						ok = ok && a.setNoValue(x);
					}
				});
				
				return ok;
			};
		}(a.x));
				
		a.x.ondomain (function (b) {
			return function (a) {
				var da = a.getValues();
				var db = b.getValues();
				var ok = true;
						
				db.forEach (function (x) {
					if (
						(da.indexOf(x-1) === -1)
						&& (da.indexOf(x+1) === -1)
					) {
						ok = ok && b.setNoValue(x);
					}
				});
				
				return ok;
			};
		}(b.x));
		
	},
	"middle": function (v, grid, a) {
		var domain = [];
		for (var i=1; i<grid.w-1; i++) {
			domain.push(i);
		}

		a.x = v({domain:domain});
		
		
	},
	"immediately to the left of": function (v, grid, a, b) {
		var domain = [];
		for (var i=0; i<grid.w-1; i++) {
			domain.push(i);
		}

		a.x = v({domain:domain});
		
		var domain = [];
		for (var i=1; i<grid.w; i++) {
			domain.push(i);
		}
		
		b.x = v({domain:domain});
		
		b.x.ondomain (function (a) {
			return function (b) {
				var da = a.getValues();
				var db = b.getValues();
				var ok = true;
				da.forEach (function (x) {
					if (db.indexOf(x+1) === -1) {
						ok = ok && a.setNoValue(x);
					}
				});
				
				return ok;
			};
		}(a.x));
				
		a.x.ondomain (function (b) {
			return function (a) {
				var da = a.getValues();
				var db = b.getValues();
				var ok = true;
				
				db.forEach (function (x) {
					if (da.indexOf(x-1) === -1) {
						ok = ok && b.setNoValue(x);
					}
				});
				
				return ok;
			};
		}(b.x));
	},
	"same position as": function (v, grid, a, b) {
		var domain = [];
		for (var i=0; i<grid.w; i++) {
			domain.push(i);
		}

		a.x = v({domain:domain});
		b.x = v({domain:domain});
		
		b.x.ondomain (function (a) {
			return function (b) {
				var da = a.getValues();
				var db = b.getValues();
				var ok = true;
								
				da.forEach (function (x) {
					if (db.indexOf(x) === -1) {
						ok = ok && a.setNoValue(x);
					}
				});
				
				return ok;
			};
		}(a.x));
						
		a.x.ondomain (function (b) {
			return function (a) {
				var da = a.getValues();
				var db = b.getValues();
				var ok = true;
								
				db.forEach (function (x) {
					if (da.indexOf(x) === -1) {
						ok = ok && b.setNoValue(x);
					}
				});
				
				return ok;
			};
		}(b.x));
	}
};

function setVars (a, b) {
	if ((a && b) && (a.user.v!==b.user.v) && (a.user.y===b.user.y)) {
		a.notUnify(b);
	}
};
	
function setupClue (factory, grid, clue) {
	constrains[clue.type](factory.v, grid, clue.a, clue.b);

	// create a user space to setup meta information on variable.
	clue.a.x.user = {
		y: clue.a.y,
		v: clue.a.v
	};
	
	if (clue.b) {
		clue.b.x.user = {
			y: clue.b.y,
			v: clue.b.v
		};	
	}

	factory.getVars().forEach (function (v) {
		setVars(clue.a.x, v);
		if (clue.b) {
			setVars(clue.b.x, v);
		}
	});

};

function checkSolution (grid, vars) {
	
	var res = [];
	var items = [];
	var s = [];

	vars.forEach (function (v) {
		var x = v.getValue();
		var y = v.user.y;
		
		if (x!==undefined) {
			if (items.indexOf(v.user.v) === -1) {
				items.push(v.user.v);
			}
			
			if ((res[x+y*grid.w]===undefined) || (res[x+y*grid.w] === v.user.v)) {
				res[x+y*grid.w] = v.user.v;
				s[y] = s[y] || [];
				s[y][x] = v.user.v;
			}
			else {
				console.log("found a bug, no more than on item can be at same position...");
				return false;
			}
		}
	});
	
	var total = grid.h*grid.w;
	
	if ((res.length === total) && (items.length === total)) {
		return s;
	}
	
	return false;
}

function solve (grid, clues, ignore) {
	var items = {};
	// create a new factory, we want a clean variable enviroment,
	var factory = new Variables();

	for (var i=0; i<clues.length; i++) {
		if (i !== ignore) {
			var clue = clues[i];
			setupClue(factory, grid, clue);
			
			items[clue.a.v] = items[clue.a.v] || clue.a.x;
			items[clue.a.v].unify(clue.a.x);
			
			if (clue.b) {
				items[clue.b.v] = items[clue.b.v] || clue.b.x;	
				items[clue.b.v].unify(clue.b.x);
			}
			
			var count=0;
			
			backtrack(factory, function (vars) {
				// Backtrack will find solution that will satisfy all current variables,
				// but the solutions found may not solve the puzzle, ex: 1 variable will always have a solution, but is not a puzzle solution.
				s = checkSolution(grid, vars);
				if (s) {
					count++;
					if (count > 1) {
						return false; // stop backtrack there is more than one solution,
					}
				}
			});
			
			if (count === 1) {
				return i;
			}
		}
	};

	return false;
};



// ---
function solve2 (grid, clues, callback) {
	var items = {};
	// create a new factory, we want a clean variable enviroment,
	var factory = new Variables();

	for (var i=0; i<clues.length; i++) {
		var clue = clues[i];
		setupClue(factory, grid, clue);
			
		items[clue.a.v] = items[clue.a.v] || clue.a.x;
		items[clue.a.v].unify(clue.a.x);
			
		if (clue.b) {
			items[clue.b.v] = items[clue.b.v] || clue.b.x;	
			items[clue.b.v].unify(clue.b.x);
		}
	}
			
	backtrack(factory, function (vars) {
		callback(checkSolution(grid, vars));
	});
};



exports.getJSON = getJSON;
exports.solve = solve;
exports.solve2 = solve2;

exports.genGrid = genGrid;

