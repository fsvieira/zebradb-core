var v = require("../../lib/variable").v;
var genetic = require("../../lib/genetic").find;

var fs = require("fs");

/* ===============
 * 	  Gen grid
 * 
 * - Note: Solution items order doesnt matter since random solutions 
 *   can be generated by item replacement.
 * ===============
 */
function genGrid (cols, lines, prefix) {
	prefix = prefix || "var";
	
	var r = {
		solution: [],
		posy: {},
		w: cols,
		h: lines
	};
	
	for (var y=0; y<lines; y++) {
		var vars = [];
		var domain = [];
		var strVars = [];
		for (var x=0; x<cols; x++) {
			var id = prefix + y+ "_" +x;
			domain.push(id);
			r.posy[id] = y;
		}
		r.solution.push (domain);
	}
	
	r.constrains = constrains(r);
	
	return r;
};



/* ===============
 * 		Get all possible constrains
 * 
 * - Returns a list of all possible constrains that can be applyed to grid.
 * ===============
 */
function constrains (grid) {
	var constrains = [];
	var solution = grid.solution;
	
	function getDomain (min, max) {
		var d = [];
		for (var i=min; i<max; i++) {
			d.push(i);
		};

		return d;
	};
	
	var middle = getDomain(1, grid.w-1);
	var leftOfa = getDomain(0, grid.w-1);
	var leftOfb = getDomain(1, grid.w);
	var all = getDomain(0, grid.w);
	
	function getVar (yA, domainA, vA) {
		return {
			y: yA,
			x: v({domain: domainA}),
			v: vA
		};
	};
	
	function getClue (typeA, a, b) {
		var clue = {
			type: typeA,
			a: a,
		};
		
		if (b) {clue.b = b;}
		
		return clue;
	};

	// Gen "item" clues,
	for (var y=0; y<grid.h; y++) {
		for (var x=1; x < grid.w; x++) {
			var a = getVar(y, all, solution[y][x]);
			constrains.push(getClue("item", a));
		}
	}
	
	// Gen "middle" clues,
	for (var y=0; y<grid.h; y++) {
		for (var x=1; x < grid.w-1; x++) {
			var a = getVar(y, middle, solution[y][x]);
			constrains.push(getClue("middle", a));
		}
	}
	
	// Gen "immediately to the left of" and "next to" clues,
	for (var x=0; x < grid.w-1; x++) {
		for (var y=0; y<grid.h; y++) {
			for (var y2=0; y2<grid.h; y2++) {
				// immediately to the left of,
				var a = getVar(y, leftOfa, solution[y][x]);
				var b = getVar(y2, leftOfb, solution[y2][x+1]);
				var clue = getClue("immediately to the left of", a, b);
				constrains.push(clue);
				
				clue.a.x.change (function (b) {
					return function (a) {
						var da = a.getValues();
						var db = b.getValues();
						
						da.forEach (function (x) {
							if (db.indexOf(x+1) === -1) {
								a.setNoValue(x);
							}
						});
					};
				}(clue.b.x));
				
				clue.b.x.change (function (a) {
					return function (b) {
						var da = a.getValues();
						var db = b.getValues();
						
						db.forEach (function (x) {
							if (da.indexOf(x-1) === -1) {
								b.setNoValue(x);
							}
						});
					};
				}(clue.a.x));
				
				// next to,
				var a = getVar(y, all, solution[y][x]);
				var b = getVar(y2, all, solution[y2][x+1]);
				var clue = getClue("next to", a, b);
				
				constrains.push(clue);
				
				clue.a.x.change (function (b) {
					return function (a) {
						var da = a.getValues();
						var db = b.getValues();
						
						da.forEach (function (x) {
							if (
								(db.indexOf(x+1) === -1)
								&& (db.indexOf(x-1) === -1)
							) {
								a.setNoValue(x);
							}
						});
					};
				}(clue.b.x));
				
				clue.b.x.change (function (a) {
					return function (b) {
						var da = a.getValues();
						var db = b.getValues();
						
						db.forEach (function (x) {
							if (
								(da.indexOf(x-1) === -1)
								&& (da.indexOf(x+1) === -1)
							) {
								b.setNoValue(x);
							}
						});
					};
				}(clue.a.x));
			}
		}
	}

	// Gen "same position as" clues,
	for (var x=0; x < grid.w; x++) {
		for (var y=0; y<grid.h; y++) {
			for (var y2=y+1; y2<grid.h; y2++) {
				var a = getVar(y, all, solution[y][x]);
				var b = getVar(y2, all, solution[y2][x]);
				var clue = getClue("same position as", a, b);
				
				constrains.push(clue);
				
				clue.a.x.change (function (b) {
					return function (a) {
						var da = a.getValues();
						var db = b.getValues();
								
						da.forEach (function (x) {
							if (db.indexOf(x) === -1) {
								a.setNoValue(x);
							}
						});
					};
				}(clue.b.x));
						
				clue.b.x.change (function (a) {
					return function (b) {
						var da = a.getValues();
						var db = b.getValues();
								
						db.forEach (function (x) {
							if (da.indexOf(x) === -1) {
								b.setNoValue(x);
							}
						});
					};
				}(clue.a.x));
			}
		}
	}
	
	// Make variables distinct.
	var variables = {};

	function setVars (a, b) {
		if ((a && b) && (a.v!==b.v) && (a.y===b.y)){
			a.x.not_unify(b.x);
		}
	};

	for (var i=0; i<constrains.length-1; i++) {
		var clue1 = constrains[i];
		for (var j=i+1; j<constrains.length; j++) {
			var clue2 = constrains[j];
				
			setVars(clue1.a, clue2.a);
			setVars(clue1.a, clue2.b);
			setVars(clue1.b, clue2.b);
		}
	}

	return constrains;
};

/*
 * check solution functions,
 */
function countValues (state) {
	var count = 0;
	state.forEach (function (line) {
		line.forEach (function (item) {
			count += item?1:0;
		});
	});

	return count;
};

function fillState (grid, clues) {
	// gen init state (empty state). 
	var state = [];
	for (var y=0; y<grid.h; y++) {
		for (var x=0; x<grid.h; x++) {
			state[y] = state[y] || [];
			state[y][x] = undefined; 
		}
	}

	clues.forEach (function (clue) {
		var x = clue.a.x.getValue();
		if (x!==undefined) {
			state[clue.a.y][x]=clue.a.v;
		}
		
		if (clue.b && (x = clue.b.x.getValue())!==undefined) {
			state[clue.b.y][x]=clue.b.v;
		}
	});
	
	return countValues(state);
};


/*
 * Save and load vars,
 */
function saveAndLoad () {
	var stack = [];

	function save (vars) {
		var save = [];
		var check = [];
		vars.forEach (function (v) {
			if (check.indexOf(v.share) === -1){
				save.push(v.cloneShare());
			}
		});
		
		stack.push(save);
	}

	function load () {
		var load = stack.pop();
		load.forEach (function (share) {
			share.equal.forEach(function (v) {
				v.share = share;
			});
		});
	};

	return {load: load, save: save};
};

function countDiff (clues) {
	var items = [];
	clues.forEach (function (clue) {
		if (items.indexOf(clue.a.v) === -1) {
			items.push(clue.a.v);
		}
		
		if (clue.b && (items.indexOf(clue.b.v) === -1)) {
			items.push(clue.b.v);
		}
	});
	
	return items.length;
};

function getSaveClues (grid, find) {
	var filename = "templates/template-"+ grid.w + "x" + grid.h + "-" + find +".json";
	console.log("Puzzles are going to be saved to " + filename);
	var solutions = [];

	// TODO: Do sync 
	fs.readFile (filename, function (err, data) {
		if (err) {
			console.log(err);
		}
		else {
			solutions = JSON.parse(data);
		}
	});

	return function (clues) {
		var r = [];
		
		clues.forEach (function (clue) {
			if (clue.b) {
				r.push({
					type: clue.type,
					a: {
						v: clue.a.v,
						y: clue.a.y
					},
					b: {
						v: clue.b.v,
						y: clue.b.y
					}
				});
			}
			else {
				r.push({
					type: clue.type,
					a: {
						v: clue.a.v,
						y: clue.a.y
					}
				});
			}
		});
		
		
		solutions.push(r);
		console.log("Save Solution: " + solutions.length);
		console.log(JSON.stringify(r));


		fs.writeFileSync(filename, JSON.stringify(solutions));
	};

};

function gen (w, h, size, max) {
	var sl = saveAndLoad();
	var save = sl.save;
	var load = sl.load;

	var grid = genGrid (w, h);
	var saveClues = getSaveClues (grid, max);
	
	// get all vars from clues,
	var vars = [];
	grid.constrains.forEach (function (clue) {
		if (vars.indexOf(clue.a.x) === -1) {
			vars.push(clue.a.x);
		}

		if (clue.b && vars.indexOf(clue.b.x) === -1) {
			vars.push(clue.b.x);
		}
	});

	function test (clues) {
		var count = countDiff(clues);
		
		if (count === grid.w*grid.h) {
			save(vars);
			var items = {};
			
			clues.forEach (function (clue) {
				items[clue.a.v] = items[clue.a.v] || clue.a.x;
				items[clue.a.v].unify(clue.a.x);
				if (clue.b) {
					items[clue.b.v] = items[clue.b.v] || clue.b.x;	
					items[clue.b.v].unify(clue.b.x);
				}
			});

			vars.forEach (function (v) {
				v.tryValues();
			});
			
			var countState = fillState(grid, clues);
			load();
			
			return {count: countState+count, sol: (countState === grid.w*grid.h)};
		}
		
		return {count: count, sol: false};
	};

	var solutions = genetic(grid.constrains, size, test, max, saveClues);
	
	// toJson (grid.constrains);

	return solutions;
};

gen (5, 5, 20, 1);
// gen (5, 5, 19, 10);
// gen (5, 5, 19, 10);
// gen (5, 5, 18, 10);
// gen (5, 5, 17, 10); // ??



