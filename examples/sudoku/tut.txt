# Sudoku Solver

In this tutorial we will write a solver for sudoku puzzles (9x9 grid).

First lets include variable lib and setup a test puzzle:
<pre>
var Variable = require("../../lib/variable");

var puzzle = [
	0, 0, 0,  7, 0, 0,  0, 0, 0,
	1, 0, 0,  0, 0, 0,  0, 0, 0,
	0, 0, 0,  4, 3, 0,  2, 0, 0,
	
	0, 0, 0,  0, 0, 0,  0, 0, 6,
	0, 0, 0,  5, 0, 9,  0, 0, 0,
	0, 0, 0,  0, 0, 0,  4, 1, 8,
	
	0, 0, 0,  0, 8, 1,  0, 0, 0,
	0, 0, 2,  0, 0, 0,  0, 5, 0,
	0, 4, 0,  0, 0, 0,  3, 0, 0,
];
</pre>

I have choose 0 to be the unknown value in our puzzle.
Now lets create the variables for this puzzle:

<pre>
function setupPuzzle (puzzle) {
	var v = Variable.v;
	
	// create variables,
	var solution = [];
	puzzle.forEach (function (value) {
		solution.push(v(value?{domain: [value]}:{domain: [1, 2, 3, 4, 5, 6, 7, 8, 9]}));
	});

       return solution;
}

var solution = setupPuzzle(puzzle);
</pre>
 
The function will create all variables for the puzzles. If a value is defined than the variable is initialized with that value, if not variable is initialized with domain=[1, 2, 3, 4, 5, 6, 7, 8, 9];


To better see what is happening lets define print function:
<pre>
function print(solution) {
	var s = "";
	for (var i=0; i!==9*9; i++) {
		s +="[" + solution[i].getValues() + "]" + (((i+1)%9)?" ":"\n");
	}
	console.log(s);
}

print(solution);
</pre>

The output is not very pretty, especially if there is still a lot of unknown variables:
<pre>
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [7] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9]
[1] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9]
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [4] [3] [1,2,3,4,5,6,7,8,9] [2] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9]
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [6]
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [5] [1,2,3,4,5,6,7,8,9] [9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9]
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [4] [1] [8]
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [8] [1] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9]
[1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [2] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [5] [1,2,3,4,5,6,7,8,9]
[1,2,3,4,5,6,7,8,9] [4] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9] [3] [1,2,3,4,5,6,7,8,9] [1,2,3,4,5,6,7,8,9]
</pre>

We need to add sudoku constrains for our variables, sudoku constrains are:

* lines: distinct values for lines,
* rows: distinct values for rows,
* squares: distinct values for squares.

So to do this I will change setupPuzzle function to group this values as lines, rows and squares like this:
<pre>
function setupPuzzle (puzzle) {
	var v = Variable.v;
	
	// create variables,
	var solution = {
		lines: {},
		rows: {},
		squares: {},
		all: [],
	};
	puzzle.forEach (function (value, index) {
		var p = v(value?{domain: [value]}:{domain: [1, 2, 3, 4, 5, 6, 7, 8, 9]});
		var y = Math.floor(index/9);
		var x = index - y*9;

		var squareOffset = Math.floor(x/3) + Math.floor(y/3)*3 ;
		
		solution.all.push(p);
		(solution.lines[x] = solution.lines[x] || []).push(p);
		(solution.rows[y] = solution.rows[y] || []).push(p);
		(solution.squares[squareOffset] = solution.squares[squareOffset] || []).push(p);
		
	});

	return solution.all;
}
</pre>

Now that we have all variables in correct groups we write the code to make variables distinct (we will use notUnify to do this)

<pre>
function distinct (groups) {
	for (var g in groups) {
		var vars = groups[g];

		// mk all vars in this group distinct,
		for (var i=0; i!==vars.length; i++) {
			var a = vars[i];
			for (var j=i; j!==vars.length; j++) {
				var b = vars[j];
				a.notUnify(b);
			}
		}
	}
}

distinct(solution.lines);
distinct(solution.rows);
distinct(solution.squares);
</pre>

After applying constrains we will have less possible values when we print the solution:
<pre>
[2,3,4,5,6,8,9] [2,3,5,6,8,9] [3,4,5,6,8,9] [7] [1,2,5,6,9] [2,5,6,8] [1,5,6,8,9] [3,4,6,8,9] [1,3,4,5,9]
[1] [2,3,5,6,7,8,9] [3,4,5,6,7,8,9] [2,6,8,9] [2,5,6,9] [2,5,6,8] [5,6,8,9] [3,4,6,7,8,9] [3,4,5,7,9]
[5,6,7,8,9] [5,6,7,8,9] [5,6,7,8,9] [4] [3] [5,6,8] [2] [6,7,8,9] [1,5,7,9]
[2,3,4,5,7,8,9] [1,2,3,5,7,8,9] [1,3,4,5,7,8,9] [1,2,3,8] [1,2,4,7] [2,3,4,7,8] [5,9] [2,3,9] [6]
[2,3,4,6,8] [1,2,3,6,8] [1,3,4,6,8] [5] [1,2,4,6] [9] [7] [2,3] [2,3]
[2,3,5,6,7,9] [2,3,5,6,7,9] [3,5,6,7,9] [2,3,6] [2,6,7] [2,3,6,7] [4] [1] [8]
[3,5,6,7,9] [3,5,6,7,9] [3,5,6,7,9] [2,3,6,9] [8] [1] [6,9] [2,4,6,7,9] [2,4,7,9]
[3,6,7,8,9] [1,3,6,7,8,9] [2] [3,6,9] [4,6,7,9] [3,4,6,7] [1,6,8,9] [5] [1,4,7,9]
[5,6,7,8,9] [4] [1,5,6,7,8,9] [2,6,9] [2,5,6,7,9] [2,5,6,7] [3] [2,6,7,8,9] [1,2,7,9]
</pre>

The last thing to do is to solve to solve it, for that we are going to try all values, so I will 
use the tryValues() to do this:
<pre>
var sl = Variable.saveAndLoad(solution.all);
	
solution.all.forEach (function (a) {
	a.tryValues(sl);
});
</pre>
The function tryValues will try all possible values for each puzzle variable, this will remove values that will lead to an invalid solution.

So the result is:
<pre>
[2] [3] [4] [7] [1] [5] [6] [8] [9]
[1] [5] [6] [9] [2] [2] [8] [3] [4]
[9] [8] [9] [4] [3] [8] [2] [7] [1]
[3] [2] [7] [1] [4] [7] [5] [9] [6]
[4] [1] [8] [5] [6] [9] [7] [2] [3]
[5] [9] [3] [6] [7] [3] [4] [1] [8]
[7] [6] [5] [3] [8] [1] [9] [4] [2]
[6] [7] [2] [3] [9] [4] [1] [5] [7]
[8] [4] [1] [2] [5] [6] [3] [6] [7]
</pre>
