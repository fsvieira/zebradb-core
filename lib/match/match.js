"use strict";

const Ids = require("../zvs/ids");

const TYPE_CONSTANT = 0;
const TYPE_VARIABLE = 1;
const TYPE_TUPLE = 2;
const TYPE_DOMAIN = 3;

const types = {
	constant: TYPE_CONSTANT,
	variable: TYPE_VARIABLE,
	tuple: TYPE_TUPLE,
	domain: TYPE_DOMAIN
};

class Match {

	constructor (zvs) {
		this.zvs = zvs;
		this.symbols = new Ids();
		this.stateIDs = new Ids();
		this.states = {};
		this.start = this.stateIDs.id([]);
		this.transitions = {};
	}

	transition (from, symbol, to) {
		const t = this.transitions[from] = this.transitions[from] || {};
		const s = t[symbol] = t[symbol] || [];
		if (s.indexOf(to) === -1) {
			s.push(to);
		}
	}

	getStateJoinID (states) {
		if (states.length > 1) {
			const tuples = [];

			for (let i = 0; i < states.length; i++) {
				const s = states[i];
				const state = this.states[s];

				for (let j = 0; j < state.length; j++) {
					const t = state[j];

					if (tuples.indexOf(t) === -1) {
						tuples.push(t);
					}
				}

				tuples.sort();
			}

			const stateID = this.stateIDs.id(tuples);

			this.states[stateID] = tuples;
			return stateID;
		}
		else {
			return states[0];
		}
	}

	add (tupleID, variables) {
		/*
		{Position, Variable, Length} => id,
		{Position, Constant:value, Length} => id,
		{Position, Tuple, Length} => id.
		{Position, Domain, Length} => id.
		*/

		// Create state,
		const stateData = [tupleID];
		const stateID = this.stateIDs.id(stateData);
		this.states[stateID] = stateData;

		const tuple = this.zvs.getObject(this.zvs.branches.root, tupleID);

		// Start transition,
		this.transition(
			this.start,
			this.symbols.id({
				type: TYPE_TUPLE,
				length: tuple.data.length
			}),
			stateID
		);

		let value;
		for (let i = 0; i < tuple.data.length; i++) {

			const v = tuple.data[i];
			value = undefined;

			if (v.type === "variable") {
				variables[tuple.data.length] =
					variables[tuple.data.length] || {};

				const s = variables[tuple.data.length][i] =
					variables[tuple.data.length][i] || {
						variables: [],
						symbols: []
					};

				s.variables.push(stateID);
			}
			else if (v.type === "constant") {
				value = v.data;
			}
			else if (v.type === "tuple") {
				value = v.data.length;
			}

			const symbol = this.symbols.id({
				position: i,
				type: types[v.type],
				value,
				length: tuple.data.length
			});

			variables[tuple.data.length] = variables[tuple.data.length] || {};

			const s = variables[tuple.data.length][i] =
				variables[tuple.data.length][i] || {
					variables: [],
					symbols: []
				};

			if (s.symbols.indexOf(symbol) === -1) {
				s.symbols.push(symbol);
			}

			variables[tuple.data.length][i].symbols.push(symbol);

			this.transition(this.start, symbol, stateID);
			this.transition(stateID, symbol, stateID);

			// repeat for domains,
			if (
				v.type === 'constant' || 
				v.type === 'domain' || 
				v.type === 'variable'
			) {
				const symbol = this.symbols.id({
					position: i,
					type: TYPE_DOMAIN,
					value: undefined,
					length: tuple.data.length
				});

				if (s.symbols.indexOf(symbol) === -1) {
					s.symbols.push(symbol);
				}
	
				variables[tuple.data.length][i].symbols.push(symbol);
	
				this.transition(this.start, symbol, stateID);
				this.transition(stateID, symbol, stateID);
			}
		}
	}

	isLoop (g, t) {
		const done = g[t].slice();
		const tuples = done.slice();

		if (tuples) {
			while (tuples.length) {
				const tuple = tuples.pop();

				if (tuple === t) {
					return true;
				}

				// Insert all tuples from graph relations.
				const ts = g[tuple];

				for (let i = 0; i < ts.length; i++) {
					const t = ts[i];

					if (done.indexOf(t) === -1) {
						done.push(t);
						tuples.push(t);
					}
				}
			}
		}

		return false;
	}

	graph (tuples, branchId) {
		const g = {};
		const loops = {};

		branchId = branchId || this.zvs.branches.root;

		tuples.forEach(t => {
			const tuple = this.zvs.getData(branchId, t);
			const data = this.zvs.getData(branchId, tuple.data);

			g[t] = [];

			for (let i = 0; i < data.length; i++) {
				const dID = data[i];
				const type = this.zvs.getData(
					branchId,
					this.zvs.getData(branchId, dID).type
				);

				if (type === "tuple") {
					const mt = this.match(branchId, dID);

					if (mt) {
						for (let j = 0; j < mt.length; j++) {
							const m = mt[j];

							if (g[t].indexOf(m) === -1) {
								g[t].push(m);
							}
						}
					}

					/*
					Unfortunately some are generated by multiply process, ...
					we need to remove them, so we can test the user definitions.

					else {
					    throw "Definition " +
					    utils.toString(this.zvs.getObject(branchId, t)) +
					    " will always fail because of subtuple " +
					    utils.toString(this.zvs.getObject(branchId, dID));
					}*/
				}
			}
		});

		tuples.forEach(t => {
			loops[t] = this.isLoop(g, t);
		});

		return { graph: g, loops };
	}

	setVariablesTransitions (vs) {
		if (vs.variables.length > 0 && vs.symbols.length > 0) {
			for (let i = 0; i < vs.variables.length; i++) {
				const state = vs.variables[i];

				for (let j = 0; j < vs.symbols.length; j++) {
					const symbol = vs.symbols[j];

					this.transition(this.start, symbol, state);
					this.transition(state, symbol, state);
				}
			}
		}
	}

	addTuples (tuples) {
		const variables = {};

		tuples.forEach(t => {
			this.add(t, variables);
		});

		// Create symbol variable transitions,
		for (let variable in variables) {
			if (variables.hasOwnProperty(variable)) {
				const positions = variables[variable];

				for (let position in positions) {
					if (positions.hasOwnProperty(position)) {
						this.setVariablesTransitions(positions[position]);
					}
				}
			}
		}

		// mk automata determinitic.
		this.deterministic();

		// set tos states to to.
		for (let from in this.transitions) {
			if (this.transitions.hasOwnProperty(from)) {
				const symbols = this.transitions[from];

				for (let symbol in symbols) {
					if (symbols.hasOwnProperty(symbol)) {
						symbols[symbol] = symbols[symbol][0];
					}
				}
			}
		}

		this.g = this.graph(tuples);
		// TODO: clean up unused states,
	}

	copySymbolsToState (joinID, symbols) {
		if (symbols) {
			for (let symbol in symbols) {
				if (symbols.hasOwnProperty(symbol)) {
					const tos = symbols[symbol];

					for (let j = 0; j < tos.length; j++) {
						const t = tos[j];
						this.transition(joinID, symbol, t);
					}
				}
			}
		}
	}

	deterministic (stateID) {
		stateID = stateID || this.start;

		const symbols = this.transitions[stateID];

		if (!symbols) {
			return;
		}

		for (let symbol in symbols) {
			if (symbols.hasOwnProperty(symbol)) {
				const states = symbols[symbol];

				if (states.length > 1) {
					const joinID = this.getStateJoinID(states);

					if (!this.transitions[joinID]) {
						for (let i = 0; i < states.length; i++) {
							const n = states[i];
							const symbols = this.transitions[n];
							this.copySymbolsToState(joinID, symbols);
						}
					}

					symbols[symbol] = [joinID];
					this.deterministic(joinID);
				}
			}
		}
	}

	getState (from, value) {
		const symbol = this.symbols.id(value);

		if (symbol) {
			const to = this.transitions[from][symbol];
			if (to === undefined &&
				value.value !== undefined &&
				value.position !== undefined
			) {
				// If is a value then try variable.
				const symbol = this.symbols.id({
					position: value.position,
					type: TYPE_VARIABLE,
					value: undefined,
					length: value.length
				});

				return this.transitions[from][symbol];
			}

			return to;
		}
	}

	match (branchId, tupleID) {
		const tuple = this.zvs.getData(branchId, tupleID);
		const tupleData = this.zvs.getData(branchId, tuple.data);

		const length = tupleData.length;

		let from = this.getState(this.start, {
			type: TYPE_TUPLE,
			length
		});

		if (from !== undefined) {
			for (let i = 0; i < length; i++) {
				const id = tupleData[i];

				let value;
				const v = this.zvs.getData(branchId, id);
				const type = this.zvs.getData(branchId, v.type);
				const data = this.zvs.getData(branchId, v.data);

				if (type === "constant") {
					value = data;
				}
				else if (type === "tuple") {
					value = data.length;
				}

				if (value || type === 'domain') {
					from = this.getState(from, {
						position: i,
						type: types[type],
						value,
						length
					});
				}

				if (from === undefined) {
					// There is no matching tuples,
					return;
				}
			}

			// Put all definitions on result.
			// Return a copy of defintions array,
			return this.states[from].slice();
		}
	}
}

module.exports = Match;
