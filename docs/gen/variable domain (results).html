<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="results">Results</h1>
<p>I finished the domains, I think they are a success but Zebradb is still unable to solve send more money puzzle.</p>
<p>Domains are good to decrease the number of branches however in some situations, like send more money puzzle, the number of combinations and branches grow so fast that it explodes the memory before branches start to decrease, and processing time also grows.</p>
<p>Solving send more money puzzle, is a big milestone for Zebradb project, has I believe many other problems will suffer from the same branch growth problem.</p>
<p>The problem with domains as they are implemented right now is that there is still a lot of possible combinations, the only solution I can think of is to make what I call conditional shared domains.</p>
<p>Currently I am using a automaton representation to extract domains, each path of the automaton represents a possible value for each variable. After constructing the automaton values for each variable are extracted as different domains and branches are created.</p>
<p>The solution of conditional shared domains skips the part of extracting and creating new branches for each possible variable domains, instead I will use the automaton domain representation to hold all possible variables domains on the same branch and add more logic to handle domains and domains operations.</p>
<p>The idea is quiet simple, each branch as set of variables, domains are represented by an automaton and subset of possible variables, each combination of possible values for each variable is a word on the automaton meaning that all possible words are encoded as paths, when a variable is replaced or canâ€™t hold a value we narrow the domains paths, at the end we get all possible solutions encoded as an automaton.</p>
<p>This is still just an idea that I going to explore in the next days.</p>
</body>
</html>
