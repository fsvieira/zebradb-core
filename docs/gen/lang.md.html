<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>lang</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body>
<h1 id="zebradb-language">Zebradb Language</h1>
<p>Zebradb has a single language (zlang) for definitions and queries. The following sections describes this language.</p>
<h2 id="comments">Comments</h2>
<p>C-style, shell-style</p>
<ul>
<li>examples:</li>
</ul>
<pre><code>/*
    Multiline comment

*/</code></pre>
<pre><code>    # single line comment.</code></pre>
<h2 id="constants">Constants</h2>
<p>A string that does not include comments, ’, (), {} and whitespaces.</p>
<ul>
<li>examples</li>
</ul>
<pre><code>    yellow red 0 1 , [ ] . = ...</code></pre>
<h2 id="variables">Variables</h2>
<p>Variables start with ’ and can be followed by varname</p>
<ul>
<li>examples</li>
</ul>
<pre><code>    &#39;a   
    # its variable &quot;a&quot;</code></pre>
<pre><code>    &#39; 
    # anonimous variable</code></pre>
<h3 id="domains">domains</h3>
<p>Domains are sets of constants (eg. {1 2 3 4}) that are associated to a variable.</p>
<ul>
<li>examples</li>
</ul>
<pre><code>    &#39;{0 1 2 3}   
    # anonimous variable can only be assigned to values 0, 1, 2 or 3.</code></pre>
<pre><code>    &#39;color{blue pink black}  
    # variable color can only be assigned to values blue, pink and black.</code></pre>
<p>For aesthetic purposes we can use : to separate the varname and domain, but its exactly the same as above.</p>
<pre><code>    &#39;color:{blue pink black}  
    #  variable color can only be assigned to values 0, 1, 2 or 3.</code></pre>
<h3 id="not-unify">not-unify ~</h3>
<p>The not unify is used to say that a variable or zlang term is not unifable with other term.</p>
<ul>
<li>examples:</li>
</ul>
<pre><code>    &#39;y~&#39;x  
    # it says that variable &#39;y does not-unify with &#39;x, &#39;y != &#39;x.</code></pre>
<pre><code>    &#39;y~yellow  
    # it says that variable &#39;y does not-unify with constant yellow, &#39;y != yellow.</code></pre>
<pre><code>    &#39;~yellow  
    # it says that anonimous variable does not-unify with constant yellow, &#39; != yellow.</code></pre>
<p>For aesthetic purposes we can rewrite the above example like this</p>
<pre><code>    ~yellow  
    #  it says that anonimous variable does not-unify with constant yellow, &#39; != yellow.</code></pre>
<pre><code>    &#39;x:{0 1}~&#39;y{0 1}  
    #  it says that &#39;x != y and both can only have the values 0 or 1, so x=0 then y=1, x=1 then y=0</code></pre>
<p>It also suports a list of zlang terms using ~{…}</p>
<pre><code>    &#39;x~{&#39;y &#39;z yellow} 
    # its says that &#39;x can&#39;t be equal to &#39;y, &#39;z and constant yellow  </code></pre>
<pre><code>    &#39;x~{&#39;y~&#39;z} 
    # its says that &#39;x != &#39;y, and &#39;y != &#39;z  </code></pre>
<pre><code>    &#39;x~&#39;y~&#39;z 
    # its says that &#39;x != &#39;y, and &#39;y != &#39;z  </code></pre>
<h2 id="tuples">Tuples</h2>
<p>Has the name says tuples are tuples of zlang terms (variables, constants, tuples, …)</p>
<ul>
<li>examples:</li>
</ul>
<pre><code>    (&#39;x = &#39;x) 
    # tuple has 3 elements, 2 &#39;x variables and one &quot;=&quot; constant</code></pre>
<pre><code>    (&#39;x != ~&#39;x) 
    # tuple has 3 elements, &#39;x variable, != constant and ~&#39;x anonimous variable that does not-unify with &#39;x</code></pre>
<pre><code>    ((blue) != ~(blue)) 
    # not-unify can also be used on tuples.</code></pre>
<h2 id="definitions-and-query">Definitions and Query</h2>
<p>Definitions and queries are only tuples.</p>
<ul>
<li>example:</li>
</ul>
<p>definitions:</p>
<pre><code>    (&#39;x != ~&#39;x)
    (&#39;x = &#39;x)</code></pre>
<p>query:</p>
<pre><code>    (blue &#39;x blue)</code></pre>
<p>output:</p>
<pre><code>    (blue = blue)</code></pre>
<ol type="1">
<li>Zebradb uses unification to evaluate the query, it basicly unifies the querie with the definitions tuple. The outer definition tuple is considered a fact, so any tuple that sucessfuly unfies with it is considered to be valid or checked, however definition inner tuples are not considered to be a fact and so unified tuples are not automaticly checked. This means that defintion inner tuples must be unifiable with other definitions.</li>
</ol>
<ul>
<li>example:</li>
</ul>
<pre><code>    ((bit &#39;x) = (bit &#39;x))</code></pre>
<p>All queries to this set of definitions will fail because tuple (bit ’x) does not unify with any definition. It can be fixed like this:</p>
<pre><code>    (bit &#39;x:{0 1})
    ((bit &#39;x) = (bit &#39;x))</code></pre>
<ol start="2" type="1">
<li>After all queries tuples are checked a solution is found.</li>
</ol>
<h3 id="hidden">Hidden</h3>
<p>A hidden list of tuples is preceded by the definition/query tuple like this:</p>
<ul>
<li>example:</li>
</ul>
<pre><code>    (mary likes food)
    (mary likes wine)

    # john likes what mary likes.
    (john likes &#39;stuff) {(mary likes &#39;stuff)}
</code></pre>
</body>
</html>
