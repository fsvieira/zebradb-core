\documentclass[11pt,a4paper]{report}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{mathrsfs}

\newcommand{\zm}{ZM}
\newcommand{\zsystem}{Zebra-machine (\zm)}
\newcommand{\var}[1]{`#1}

\newcommand{\unify}{\otimes}

\begin{document}

\title{The Great Book of Zebra}
\author{The Zebra Project}
\date{\today}
\maketitle

\chapter*{Preface}

This book is a collaborative work from the \href{zebrajs}{https://github.com/fsvieira/zebrajs} project community
and everyone is invited to participate.

The list of contributors is at the contributors section~\ref{sec:contributors} and your name can be there too :D.

This is a work in progress.

\tableofcontents

\chapter{Introduction}

This is the official book of \zsystem. Here you will find anything you need to understand in deep the \zm ,
the book covers both theoretical and practical definitions.

\zsystem is a logical symbolic computation query system, given a set of computational definitions it will
answer questions about them, therefor \zm is better suited for software validation and constrain satisfaction problems.

\section{The \zsystem}

As mentioned before \zm\ is a logical symbolic computation query system, and it consists of two parts
the definitions and the query, both parts share the same language of \zm\ terms, which is defined by
a certain formal syntax, and a set of transformation rules.

\subsection{\zm\ Language ($\mathbb{L}$)}
\paragraph{The \zm\ language ($\mathbb{L}$) of terms are defined as:}

\begin{enumerate}
\item $\mathbb{C}$ is the set of terminal symbols called constants,
\item $\mathbb{V}$ is the set of variables,
\item $(p_{0} \ldots p_{n}) \in \mathbb{T}_{0}$: $\mathbb{T}_{0}$ is the set of tuples, $(p_{0} \ldots p_{n})$ its a n-tuple where 
$p_k \in \mathbb{C} \vee p_k \in \mathbb{V}$,
\item $\mathbb{T}_{k}$ is a set of tuples, $(p_{0} \ldots p_{n}) \in \mathbb{T}_{k}$ where $k > 0$ and
$p_{i} \in \mathbb{T}_{k-1} \vee p_{i} \in \mathbb{C} \vee p_{i} \in \mathbb{V} \vee (p_{i} = \overline{q} \wedge q \in \mathbb{T}_{k-1})$ and $\overline{q}$ is the 
negation of tuple $q$.
\item $\mathbb{L} = \bigcup\limits_{i=0}^{\infty} \mathbb{T}_{i}$
\end{enumerate}

% \begin{enumerate}
% \item $\mathbb{L}_{0}$ and $\mathbb{L}_{not}$ are sets of \zm\ terms.
% \item $c \in \mathbb{C}$: $\mathbb{C}$ is the set of terminal symbols called constants, $c$ is a terminal symbol. $c \in \mathbb{L}_{0}$.
% \item $\var{p} \in \mathbb{V}$: $\mathbb{V}$ is the set of variables, $p$ is a variable. $\var{p} \in \mathbb{L}_{0}$.
% \item $(p_{0} \ldots p_{n}) \in \mathbb{T}$: $\mathbb{T}$ is the set of tuples, $(p_{0} \ldots p_{n})$ its a n-tuple of \zm\ terms. $(p_{0} \ldots p_{n}) \in \mathbb{L}_{0}$.
% \item $\overline{p}$ can be any term that is not equal to $p$, $p \in \mathbb{L}_{0}$. $\overline{p} \in \mathbb{L}_{not}$.
% \item Nothing else is a \zm\ term.
% \item $\mathbb{L} = \mathbb{L}_{0} \cup \mathbb{L}_{not}$,
% \end{enumerate}


\subsection{\zm\ Operations}

\paragraph{The powerset of set $\mathbb{S}$ is expressed as $\mathrm{P}(\mathbb{S})$}.

\paragraph{Unification ($\unify$, binary operation)} defined as
\[
    \unify: \mathbb{L} \times \mathbb{L} \rightarrow \mathbb{L}
\]

and by the rules,

\[
    \unify: \mathbb{L}_{0} \times \mathbb{L}_{0} \rightarrow \mathbb{L}_{0}
\]

\begin{enumerate}
\item $Q \unify Q = Q$
    \subitem $Q$ unifies with itself, resulting on itself.

\item $\var{p} \unify Q = Q \iff \var{p} = Q$
\item $Q \unify \var{p} = Q \iff \var{p} = Q$
    \subitem note that if $Q \in \mathbb{V}$ then rule [2] will also apply, since both $p$ and $Q$ are the same the result is also the same.

\item $(p_{0} \ldots p_{n}) \unify (q_{0} \ldots q_{n}) \iff (p_{0} \unify q_{0} \ldots p_{n} \unify q_{n})$
    \subitem $(p_{0} \ldots p_{n})$ z-tuple only unifies with other z-tuple if they have same size and all sub \zm\ terms unify.

\end{enumerate}


\[
    \unify: \mathbb{L}_{0} \times \mathbb{L}_{not} \rightarrow \mathbb{L}_{0}
\]

\begin{enumerate}
\item $Q \unify \overline{p} = Q \iff p \neq Q$
\end{enumerate}


\[
    \unify: \mathbb{L}_{not} \times \mathbb{L}_{0} \rightarrow \mathbb{L}_{0}
\]

\begin{enumerate}
\item $\overline{p} \unify Q = Q \iff p \neq Q$
\end{enumerate}

\[
    \unify: \mathbb{L}_{not} \times \mathbb{L}_{not} \rightarrow \mathbb{L}_{0}
\]

\begin{enumerate}
\item $\overline{P} \unify \overline{Q} = \var{p} \iff \var{p} \unify \overline{P} \wedge \var{p} \unify \overline{Q}$
    \subitem where $\var{p}$ is a new variable.
    \subitem note that if $P = Q$, then $\var{p} \neq (P \unify Q)$.
\end{enumerate}

Anything else is not unifiable.

\paragraph{Substitution ($\mathcal{S}$, function)} defined as:

\begin{align}
    \mathcal{S}&: \mathbb{V} \times \mathbb{L} \times \mathbb{L} \rightarrow \mathbb{L}\\
    \mathcal{S}&(v, w, t) =
    \begin{cases}
        \hfill w \hfill &\text{, if } t = v,\\
        \hfill (\mathcal{S}(v, w, t_{0}) \ldots \mathcal{S}(v, w, t_{n})) \hfill & \text{, if } t = (t_{0} \ldots t_{n})\\
        \hfill t \hfill & \text{, otherwise}
    \end{cases}
\end{align}


\paragraph{The notation $\mathbb{T}_{p}$} is used to define the set containing all of $p$ inner tuples.

\subsection{\zm\ Computation}
\paragraph{A \zm\ computation is expressed as 4-tuple $(\sigma, \delta, q, \alpha)$ where:}

\begin{enumerate}
\item $\sigma$ is a set of terminal symbols (constants),
\item $\delta$ is a set of z-tuples (definitions),
\item $q$ is a z-tuple (query),
\item $\alpha$ is the set of possible computational answers to query $q$ based on $delta$ definitions.
\end{enumerate}

\paragraph{A definition} is a fact in the system. The inner tuples of a definition are considered and called queries, therefor
for a definition to be true all of its inner tuples/queries must also be true.

\paragraph{A query} is a question to the system that is true if and only if it unifies at least with
one definition.

\paragraph{Free and bound variables} on the context of a definition all definition variables are considered
to be bound to the definition, on the context of queries all variables are free.

Bound variables will be expressed as:
\[
    ([v_{0} \ldots v_{n}] p_{0} \ldots p_{k})
\]

where $v_{i}, 0 <= i <= n$ are the tuple bound variables and $p_{j}, 0 <= j <=k$ are the tuple terms.

ex:
\[
    ([a\ b\ c]\ (\var{a}\ \var{b})\ \var{c}\ \text{yellow})
\]

Bound information and notation is used on intermidiate computation steps, therefor they are not included on the $\zm$ language.


\paragraph{Variable renaming} its necessary to ensure that distinct variables with same name are not handled as being the same.

ex:
\[
    ([p]\ \var{p}\ \var{q}) \unify ([p\ q]\ \var{p}\ \var{q})
\]

The first tuple has only $\var{p}$ as bound variable and the second tuple as $\var{p}$ and $\var{q}$ declared as bound variables.
To ensure that this variables keep their meaning, we rename the bound variables like this:

\[
    ([p_{0}]\ \var{p_{0}}\ \var{q}) \unify ([p_{1}\ q_{1}]\ \var{p_{1}}\ \var{q_{1}})
\]

After unification we get

\[
    ([p_{0}\ p_{1}\ q_{1}]\ \var{p_{0}} \unify \var{p_{1}}\ \var{q} \unify \var{q_{1}})
\]


\paragraph{A computation} is done with the following steps:

\begin{enumerate}
    \item $\delta_{0} = \{ p_{0} \unify \ldots \unify p_{|x|} : \forall x \in \mathrm{P}(\delta) \wedge \forall p_{i} \in x, i=0 \ldots |x| \}$
    \item $\delta_{1} = \{ ([v_{0} \ldots v_{n}]\ p_{0}\ p_{k}): \forall (p_{0} \ldots p_{n}) \in \delta_{0})\}$
    \subitem where $v_{0} \ldots v_{n}$ are all (bound) variables found on $(p_{0} \ldots p_{n})$ tuple.
    \subitem $\delta_{1}$ is the set of definitions with bound variables.
    \item $\alpha = \{q \unify p :\forall p \in \delta_{1}\ \wedge \forall t \in \mathcal{T}_{q \unify q} \rightarrow (\sigma, \delta, t, \alpha) \}$
    \subitem the $\alpha$ set is the result of the unification of the query $q$ with all definitions $p$ and the resulting innter tuples are
    also a valid computation.
    \subitem a computational will stop if the set of inner tuples are empty.
    \subitem a computational may not stop for some cases.
\end{enumerate}

\begin{comment}
\section{Computing Examples}

\subsection{Defining a not equal}

\[
    (\text{notEqual}\ \var{p}\ \overline{\var{p}})
\]

Ex:
\[(\sigma, \delta, q, \alpha ) = (\{\text{yellow}, \text{blue}\}, \{(\text{notEqual}\ \var{p}\ \overline{\var{p}})\}, q, \alpha)\]

\begin{enumerate}
\item $q = (\text{notEqual}\ \var{x}\ \var{x})$
\subitem $(\text{notEqual}\ \var{x}\ \var{x}) \unify ([p]\ \text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \var{x} \unify \var{p}\ \var{x} \unify \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \var{x} \unify \var{p}\ \var{x} \unify \overline{\var{p}})$
\subitem $([p]\ \text{notEqual}\ \var{x}\ \var{x}), \text{constrains}: \var{x}=\var{p} \wedge \var{x} \neq \var{p}$
\subitem variable $x$ can't be equal and not equal to $\var{p}$ at same time,
\subitem query fails to unify with any of the definitions,
\subitem $\alpha=\emptyset$, no awnsers existe for this query.

\item $q = (\text{notEqual}\  \text{yellow}\ \text{yellow})$
\subitem $([p]\ \text{notEqual}\ \text{yellow}\ \text{yellow}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \text{yellow} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \text{yellow} \text{yellow}), \text{constrains}: \text{yellow}=\var{p} \wedge \text{yellow} \neq \var{p}$
\subitem variable $p$ can't be equal and not equal to $\text{yellow}$ value at same time,
\subitem query fails to unify with any of the definitions,
\subitem $\alpha=\emptyset$, no answers exist for this query.

\item $q = (\text{notEqual}\  \text{blue}\ \text{yellow})$

\subitem $([p]\ \text{notEqual}\ \text{blue}\ \text{yellow}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \text{blue} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \text{blue} \text{yellow}), \text{constrains}: \text{blue}=\var{p} \wedge \text{yellow} \neq \var{p} \wedge \text{blue} \neq \text{yellow}$
\subitem $\alpha=\{(\text{notEqual}\  \text{blue}\ \text{yellow})\}$.

\item $q = (\text{notEqual}\ \var{p}\ \text{yellow})$

\subitem $([p]\ \text{notEqual}\ \var{p}\ \text{yellow}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem rename bound variable, $p \rightarrow x$,
\subitem $([p]\ \text{notEqual}\ \var{p}\ \text{yellow}) \unify (\text{notEqual}\ \var{x}\ \overline{\var{x}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \var{p} \unify \var{x}\ \text{yellow} \unify \overline{\var{x}})$
\subitem $([p]\ \text{notEqual} \text{p} \text{yellow}), \text{constrains}: \text{p}=\var{x} \wedge \text{yellow} \neq \var{x}$
\subitem $\alpha=\{(\text{notEqual}\  \var{p}\ \text{yellow}), \text{constrains}: \var{p} \neq \text{yellow}\}$.

\end{enumerate}

\subsection{Defining a list}

\begin{enumerate}
\item $(\text{list})$
\item $(\text{list}\ \var{item}\ (\text{list}))$
\item $(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$
\end{enumerate}

Ex:
\[
    (\sigma, \delta, q, \alpha ) = (\{\text{yellow}, \text{blue}\},
    \{
(\text{list}),
(\text{list}\ \var{item}\ (\text{list})),
(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))
    \}, q, \alpha)
\]

\begin{enumerate}
\item $q = (\text{list})$, query a empty list.
\subitem $(\text{list}) \unify (\text{list}) = (\text{list})$
\subitem all other definitions fail to unify because the number of elements in remaining definitions don't match query tuple.
\subitem $\alpha = {(\text{list})}$
\item $q = (\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list})))$
\subitem Starting with definition $\text{list}$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list})$, fail.
\subitem Next definition $(\text{list}\ \var{item}\ (\text{list}))$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list}\ \var{item}\ (\text{list}))[\text{bound}: \text{item} ]$
\subitem $(\text{list} \unify \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}))[\text{bound}: \text{item}]$
\subitem fail to unify $(list)$ with $(\text{list}\ \text{blue}\ (\text{list}))$.
\subitem Next definition $(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))[\text{bound}: \text{item}\ \text{i}\ \text{tail}]$
\subitem $(\text{list}\unify \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{i}\ \var{tail}))[\text{bound}: \text{item}\ \text{i}\ \text{tail}]$
\subitem $(\text{list}\ \text{yellow} (\text{list}\unify \text{list}\ \text{blue} \unify \var{i}\ (\text{list}) \unify \var{tail}))[\text{bound}: \text{item}\ \text{i}\ \text{tail}, \text{constrains}: \var{item} = \text{yellow}]$
\subitem $(\text{list}\ \text{yellow} (\text{list}\ \text{blue}\ (\text{list})))
[\text{bound}: \text{item}\ \text{i}\ \text{tail}, \text{constrains}: \var{item} = \text{yellow}\ \var{i}=\text{blue}\ \var{tail}=(\text{list})]$
\subitem the next step is to unify all sub-tuples that are not yet checked with definitions, this are: $(\text{list}\ \text{blue}\ (\text{list}))$ and $(\text{list}))$,
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (list)$, fail.
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{item}\ (\text{list}))[\text{bound}: item]$
\subitem $(\text{list}\unify \text{list}\ \text{blue}\unify \var{item}\ (\text{list}) \unify (\text{list}))[\text{bound}: item]$
\subitem $(\text{list} \text{blue} (\text{list})))[\text{bound}: item, \text{constrains}: \var{item}=\text{blue}]$, succeed.
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$, fail.
\subitem Finally $(list)$ will only unify with $(list)$ definition, ending the process and resulting on $\alpha = \{ (\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \}$
\end{enumerate}

\subsection{What john likes?}

A simple example of querying facts.

We start with the definitions/facts:
\begin{enumerate}

\item $(\text{mary}\ \text{likes}\ \text{wine}\ \var{p})$
\subitem mary likes wine.

\item $(\text{mary}\ \text{likes}\ \text{john}\ \var{p})$
\subitem mary likes john.

\item $(\text{peter}\ \text{likes}\ \text{peter}\ \var{p})$
\subitem peter likes himself.

\item $(\text{john}\ \text{likes}\ \var{stuff}\ (\text{mary}\ \text{likes}\ \var{stuff}\ \var{p}))$
\subitem john likes everything that mary likes.

\item $(\text{john}\ \text{likes}\ \var{person}\ (\var{person}\ \text{likes}\ \text{wine}\ \var{p}))$
\subitem john likes anyone that likes wine.

\item \[
    (\text{john}\ \text{likes}\ \var{person}\ (\text{list}\ (\var{person}\ \text{likes}\ \var{person}\ \var{p}) (\text{list}\ (\text{notEqual}\ \var{person} \text{john})\ (\text{list}))))
\]
\subitem john likes anyone that likes themselves.

\end{enumerate}

\end{comment}

\section{Computing Examples (implementation)}

\subsection{Defining a not equal}

\[
    (\text{notEqual}\ \var{p}\ \overline{\var{p}})
\]

Ex:
\[(\sigma, \delta, q, \alpha ) = (\{\text{yellow}, \text{blue}\}, \{(\text{notEqual}\ \var{p}\ \overline{\var{p}})\}, q, \alpha)\]


\begin{enumerate}
\item $q = (\text{notEqual}\ \var{x}\ \var{x})$
\subitem $(\text{notEqual}\ \var{x}\ \var{x}) \unify ([p]\ \text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \var{x} \unify \var{p}\ \var{x} \unify \overline{\var{p}})$
\subitem unify constants, $([p]\ \text{notEqual}\ \var{x} \unify \var{p}\ \var{x} \unify \overline{\var{p}})$,
\subitem replace bound variables $[p]$ by their unifing part, and dispose the variable.
\subitem in this case $\var{p} \rightarrow \var{x}$, $(\text{notEqual}\ \var{x} \var{x} \unify \overline{\var{x}})$,
\subitem variable $x$ can't be equal and not equal to $x$ at same time,
\subitem query fails to unify with any of the definitions,
\subitem $\alpha=\emptyset$, no awnsers existe for this query.

\item $q = (\text{notEqual}\  \text{yellow}\ \text{yellow})$
\subitem $(\text{notEqual}\ \text{yellow}\ \text{yellow}) \unify ([p]\ \text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \text{yellow} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})$
\subitem unify constants, $([p]\ \text{notEqual}\ \text{yellow} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})$,
\subitem replace bound variables $[p]$ by their unifing part, and dispose the variable.
\subitem in this case $\var{p} \rightarrow \text{yellow}$, $(\text{notEqual}\ \text{yellow}\ \text{yellow} \unify \overline{\text{yellow}})$,
\subitem $\text{yellow}$ can't unify with not $\text{yellow}$,
\subitem query fails to unify with any of the definitions,
\subitem $\alpha=\emptyset$, no answers exist for this query.

\item $q = (\text{notEqual}\  \text{blue}\ \text{yellow})$
\subitem $(\text{notEqual}\ \text{blue}\ \text{yellow}) \unify ([p]\ \text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem $([p]\ \text{notEqual} \unify \text{notEqual}\ \text{blue} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})$
\subitem unify constants, $([p]\ \text{notEqual}\ \text{blue} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})$,
\subitem replace bound variables $[p]$ by their unifing part, and dispose the variable.
\subitem in this case $\var{p} \rightarrow \text{blue}$, $(\text{notEqual}\ \text{blue} \text{yellow} \unify \overline{\text{blue}})$,
\subitem $\text{yellow}$, will never be unifiable with $\text{blue}$, so it can be solved to $(\text{notEqual}\ \text{blue}\ \text{yellow})$,
\subitem $\alpha=\{(\text{notEqual}\ \text{blue}\ \text{yellow})\}$.

\item $q = (\text{notEqual}\ \var{p}\ \text{yellow})$

\subitem $(\text{notEqual}\ \var{p}\ \text{yellow}) \unify ([p]\ \text{notEqual}\ \var{p}\ \overline{\var{p}})$
\subitem rename bound variable, $p \rightarrow x$,
\subitem $(\text{notEqual}\ \var{p}\ \text{yellow}) \unify ([x]\ \text{notEqual}\ \var{x}\ \overline{\var{x}})$
\subitem $([x]\ \text{notEqual} \unify \text{notEqual}\ \var{p} \unify \var{x}\ \text{yellow} \unify \overline{\var{x}})$
\subitem unify constants, $([x]\ \text{notEqual}\ \var{p} \unify \var{x}\ \text{yellow} \unify \overline{\var{x}})$
\subitem replace bound variables $[x]$ by their unifing part, and dispose the variable.
\subitem in this case $\var{x} \rightarrow \var{p}$, $(\text{notEqual}\ \var{p} \text{yellow} \unify \overline{\var{p}})$
\subitem $\alpha=\{(\text{notEqual}\ \var{p} \text{yellow} \unify \overline{\var{p}})\}$.
\end{enumerate}


\subsection{Defining a list}

\begin{enumerate}
\item $(\text{list})$
\item $(\text{list}\ \var{item}\ (\text{list}))$
\item $(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$
\end{enumerate}

Ex:
\[
    (\sigma, \delta, q, \alpha ) = (\{\text{yellow}, \text{blue}\},
    \{
(\text{list}),
(\text{list}\ \var{item}\ (\text{list})),
(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))
    \}, q, \alpha)
\]

\begin{enumerate}
\item $q = (\text{list})$, query a empty list.
\subitem $(\text{list}) \unify (\text{list}) = (\text{list} \unify \text{list}) = (\text{list})$
\subitem all other definitions fail to unify because the number of elements in remaining definitions don't match query tuple.
\subitem $\alpha = \{(\text{list})\}$
\item $q = (\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list})))$
\subitem Starting with definition $(\text{list})$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list})$, fail.
\subitem Next definition $(\text{list}\ \var{item}\ (\text{list}))$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify ([item]\ \text{list}\ \var{item}\ (\text{list}))$
\subitem $([item]\ \text{list} \unify \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}))$
\subitem fail to unify $(list)$ with $(\text{list}\ \text{blue}\ (\text{list}))$.
\subitem Next definition $(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify ([\text{item}\ \text{i}\ \text{tail}]\ \text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$
\subitem $([\text{item}\ \text{i}\ \text{tail}]\ \text{list}\unify \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{i}\ \var{tail}))$
\subitem unify constants,
\subitem $([\text{item}\ \text{i}\ \text{tail}]\ \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{i}\ \var{tail}))$
\subitem $([\text{item}\ \text{i}\ \text{tail}]\ \text{list}\ \text{yellow} \unify \var{item}\ (\text{list} \unify \text{list}\ \text{blue}\ \unify \var{i}\ (\text{list}) \unify \var{tail}))$
\subitem unify constants,
\subitem $([\text{item}\ \text{i}\ \text{tail}]\ \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ \unify \var{i}\ (\text{list}) \unify \var{tail}))$

\subitem ---
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list})))
[\text{bound}: \text{item}\ \text{i}\ \text{tail}, \text{constrains}: \var{item} = \text{yellow}\ \var{i}=\text{blue}\ \var{tail}=(\text{list})]$
\subitem the next step is to unify all sub-tuples that are not yet checked with definitions, this are: $(\text{list}\ \text{blue}\ (\text{list}))$ and $(\text{list}))$,
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (list)$, fail.
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{item}\ (\text{list}))[\text{bound}: item]$
\subitem $(\text{list}\unify \text{list}\ \text{blue}\unify \var{item}\ (\text{list}) \unify (\text{list}))[\text{bound}: item]$
\subitem $(\text{list} \text{blue} (\text{list})))[\text{bound}: item, \text{constrains}: \var{item}=\text{blue}]$, succeed.
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$, fail.
\subitem Finally $(list)$ will only unify with $(list)$ definition, ending the process and resulting on $\alpha = \{ (\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \}$
\end{enumerate}



\section{Contributors}
\label{sec:contributors}

\begin{itemize}
    \item \href{https://github.com/fsvieira}{Filipe Vieira, https://github.com/fsvieira}
\end{itemize}

\end{document}