\documentclass[11pt,a4paper]{report}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}

\newcommand{\zm}{ZM}
\newcommand{\zsystem}{Zebra-machine (\zm)}
\newcommand{\var}[1]{'#1}

\newcommand{\unify}{\otimes}
\newcommand{\notUnify}{\ominus}


\begin{document}

\title{The Great Book of Zebra}
\author{The Zebra Project}
\date{\today}
\maketitle

\chapter*{Preface}

This book is a collaborative work from the \href{zebrajs}{https://github.com/fsvieira/zebrajs} project community 
and everyone is invited to participate.

The list of contributors is at the contributors section~\ref{sec:contributors} and your name can be there too :D.

This is a work in progress.

\tableofcontents

\chapter{Introduction}

This is the official book of \zsystem. Here you will find anything you need to understand in deep the \zm , 
the book covers both theoretical and practical definitions.

\zsystem is a logical symbolic computation query system, given a set of computational definitions it will 
answer questions about them, therefor \zm is better suited for software validation and constrain satisfaction problems.

\section{The \zsystem}

As mentioned before \zm\ is a logical symbolic computation query system, and it consists of two parts 
the definitions and the query, both parts share the same language of \zm\ terms, which is defined by 
a certain formal syntax, and a set of transformation rules.

\subsection{\zm\ Language ($\mathbb{L}$)}
\paragraph{The \zm\ language ($\mathbb{L}$) of terms are defined as:}

\begin{enumerate}
\item $c \in \mathbb{C}$: $\mathbb{C}$ is the set of terminal symbols called constants, $c$ is a terminal symbol. Constants are \zm\ terms.
\item $'p \in \mathbb{V}$: $\mathbb{V}$ is the set of variables, $p$ is a variable. Variables are \zm\ terms.
\item $(p_{0} \ldots p_{n}) \in \mathbb{T}$: $\mathbb{T}$ is the set of tuples, $(p_{0} \ldots p_{n})$ its a n-tuple of \zm\ terms and is a \zm\ term.
\item Nothing else is a \zm\ term.
\end{enumerate}


\subsection{\zm\ Operations}

\paragraph{Unification ($\unify$, binary operation)} defined as 
\[
    \unify: \mathbb{L} \times \mathbb{L} \rightarrow \mathbb{L}
\] 

and by the rules,

\begin{enumerate}
\item $p \unify p \implies p$
    \subitem $p$ unifies with itself, resulting on itself.

\item $\var{p} \unify Q \iff \var{p} = Q$, $p \in \mathbb{V} \wedge Q \in \mathbb{L}$
    \subitem $\var{p}$ is a variable and $Q$ is a \zm\ term, they unify iff $\var{p} = Q$.

\item $Q \unify \var{p} \iff \var{p} = Q$, $p \in \mathbb{V} \wedge Q \in \mathbb{L}$
    \subitem $\var{p}$ is a variable and $Q$ is a \zm\ term, they unify iff $\var{p} = Q$.

\item $(p_{0} \ldots p_{n}) \unify (q_{0} \ldots q_{n}) \iff (p_{0} \unify q_{0} \ldots p_{n} \unify q_{n})$
    \subitem $(p_{0} \ldots p_{n})$ z-tuple only unifies with other z-tuple if they have same size and all sub \zm\ terms unify.
    
\item Anything else fails to unify.
\end{enumerate}

\paragraph{Not-unify ($\notUnify$, binary operation)} defined as

\[
    \notUnify: \mathbb{L} \times \mathbb{L} \rightarrow \mathbb{L}
\]

and by the rules,

\begin{enumerate}
    \item $P \notUnify Q = P \iff \overline{P \unify Q}$, $P \in \mathbb{L} \wedge Q \in \mathbb{L}$
    \subitem Two \zm\ terms not-unify if they dont unify.
\item Note:
    \subitem In case of variables their values must also not-unify,
    \subitem Tuples and constants will never unify,
    \subitem If two tuples are not-unifiable then at least one of the elements is not-unifiable.
\end{enumerate}

\subsection{\zm\ Computation}
\paragraph{A \zm\ computation is expressed as 4-tuple $(\sigma, \delta, q, \alpha)$ where:}

\begin{enumerate}
\item $\sigma$ is a set of terminal symbols (constants),
\item $\delta$ is a set of z-tuples (definitions),
\item $q$ is a z-tuple (query),
\item $\alpha$ is the set of possible computational answers to query $q$ based on $delta$ definitions.
\end{enumerate}

\section{Computing Examples}

\paragraph{Unification}
\begin{enumerate}
\item $yellow \unify yellow \implies yellow$, succed.
\item $blue \unify yellow$, fail: can't unify constants with diferent value.
\item $yellow \unify (yellow)$, fail: can't unify constant and tuple.
\item $(blue\ yellow) \unify (blue\ yellow) \implies (blue \unify blue\ yellow \unify yellow) \implies (blue\ yellow)$, succed.
\end{enumerate}


\paragraph{Not-Unify}
\begin{itemize}
\item $yellow\notUnify blue$, 
    \subitem $yellow$ and $blue$ are constants and $yellow \neq blue$.
\item $(blue\ yellow)\notUnify (yellow\ blue)$, 
    \subitem $(blue\ yellow) \neq (yellow\ blue)$
\item $(blue\ 'p)\notUnify (yellow\ blue)$, 
    \subitem $'p$ is a variable and since $(blue 'p) \neq (yellow\ blue)$ then $'p \neq blue$
\item $'p\notUnify 'q$,
    \subitem $'p$ and $'q$ are variables, $'p \neq 'q$.
\end{itemize}

\section{Contributors}
\label{sec:contributors}

\begin{itemize}
    \item \href{https://github.com/fsvieira}{Filipe Vieira, https://github.com/fsvieira}
\end{itemize}

\end{document}