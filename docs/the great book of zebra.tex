\documentclass[11pt,a4paper]{report}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{mathrsfs}

\newcommand{\zm}{ZM}
\newcommand{\zsystem}{Zebra-machine (\zm)}
\newcommand{\var}[1]{`#1}

\newcommand{\unify}{\otimes}
\newcommand{\notUnify}{\ominus}


\begin{document}

\title{The Great Book of Zebra}
\author{The Zebra Project}
\date{\today}
\maketitle

\chapter*{Preface}

This book is a collaborative work from the \href{zebrajs}{https://github.com/fsvieira/zebrajs} project community 
and everyone is invited to participate.

The list of contributors is at the contributors section~\ref{sec:contributors} and your name can be there too :D.

This is a work in progress.

\tableofcontents

\chapter{Introduction}

This is the official book of \zsystem. Here you will find anything you need to understand in deep the \zm , 
the book covers both theoretical and practical definitions.

\zsystem is a logical symbolic computation query system, given a set of computational definitions it will 
answer questions about them, therefor \zm is better suited for software validation and constrain satisfaction problems.

\section{The \zsystem}

As mentioned before \zm\ is a logical symbolic computation query system, and it consists of two parts 
the definitions and the query, both parts share the same language of \zm\ terms, which is defined by 
a certain formal syntax, and a set of transformation rules.

\subsection{\zm\ Language ($\mathbb{L}$)}
\paragraph{The \zm\ language ($\mathbb{L}$) of terms are defined as:}

\begin{enumerate}
\item $\mathbb{L}_{0}$ and $\mathbb{L}_{not}$ are sets of \zm\ terms.
\item $c \in \mathbb{C}$: $\mathbb{C}$ is the set of terminal symbols called constants, $c$ is a terminal symbol. $c \in \mathbb{L}_{0}$.
\item $\var{p} \in \mathbb{V}$: $\mathbb{V}$ is the set of variables, $p$ is a variable. $\var{p} \in \mathbb{L}_{0}$.
\item $(p_{0} \ldots p_{n}) \in \mathbb{T}$: $\mathbb{T}$ is the set of tuples, $(p_{0} \ldots p_{n})$ its a n-tuple of \zm\ terms. $(p_{0} \ldots p_{n}) \in \mathbb{L}_{0}$.
\item $\overline{p}$ can be any term that is not equal to $p$, $p \in \mathbb{L}_{0}$. $\overline{p} \in \mathbb{L}_{not}$. 
\item Nothing else is a \zm\ term.
\item $\mathbb{L} = \mathbb{L}_{0} \cup \mathbb{L}_{not}$,
\end{enumerate}


\subsection{\zm\ Operations}

\paragraph{Unification ($\unify$, binary operation)} defined as 
\[
    \unify: \mathbb{L} \times \mathbb{L} \rightarrow \mathbb{L}
\] 

and by the rules,

\[
    \unify: \mathbb{L}_{0} \times \mathbb{L}_{0} \rightarrow \mathbb{L}_{0} 
\]

\begin{enumerate}
\item $Q \unify Q = Q$
    \subitem $Q$ unifies with itself, resulting on itself.

\item $\var{p} \unify Q = Q \iff \var{p} = Q$
\item $Q \unify \var{p} = Q \iff \var{p} = Q$
    \subitem note that if $Q \in \mathbb{V}$ then rule [2] will also apply, since both $p$ and $Q$ are the same the result is also the same. 

\item $(p_{0} \ldots p_{n}) \unify (q_{0} \ldots q_{n}) \iff (p_{0} \unify q_{0} \ldots p_{n} \unify q_{n})$
    \subitem $(p_{0} \ldots p_{n})$ z-tuple only unifies with other z-tuple if they have same size and all sub \zm\ terms unify.
    
\end{enumerate}


\[
    \unify: \mathbb{L}_{0} \times \mathbb{L}_{not} \rightarrow \mathbb{L}_{0} 
\]

\begin{enumerate}
\item $Q \unify \overline{p} = Q \iff p \neq Q$
\end{enumerate}


\[
    \unify: \mathbb{L}_{not} \times \mathbb{L}_{0} \rightarrow \mathbb{L}_{0} 
\]

\begin{enumerate}
\item $\overline{p} \unify Q = Q \iff p \neq Q$
\end{enumerate}

\[
    \unify: \mathbb{L}_{not} \times \mathbb{L}_{not} \rightarrow \mathbb{L}_{0} 
\]

\begin{enumerate}
\item $\overline{P} \unify \overline{Q} = \var{p} \iff \var{p} \unify \overline{P} \wedge \var{p} \unify \overline{Q}$
    \subitem where $\var{p}$ is a new variable.
    \subitem note that if $P = Q$, then $\var{p} \neq (P \unify Q)$. 
\end{enumerate}

Anything else is not unifiable.

\paragraph{Substitution ($\mathcal{S}$, function)} defined as

\begin{align}
    \mathcal{S}&: \mathbb{V} \times \mathbb{L} \times \mathbb{L} \rightarrow \mathbb{L}\\
    \mathcal{S}&(v, w, t) = 
    \begin{cases}
        \hfill w \hfill &\text{, if } t = v,\\
        \hfill (\mathcal{S}(v, w, t_{0}) \ldots \mathcal{S}(v, w, t_{n})) \hfill & \text{, if } t = (t_{0} \ldots t_{n})\\
        \hfill t \hfill & \text{, otherwise}
    \end{cases}
\end{align}



\subsection{\zm\ Computation}
\paragraph{A \zm\ computation is expressed as 4-tuple $(\sigma, \delta, q, \alpha)$ where:}

\begin{enumerate}
\item $\sigma$ is a set of terminal symbols (constants),
\item $\delta$ is a set of z-tuples (definitions),
\item $q$ is a z-tuple (query),
\item $\alpha$ is the set of possible computational answers to query $q$ based on $delta$ definitions.
\end{enumerate}


\paragraph{A definition} is a fact in the system. The inner tuples of a definition are considered and called queries, therefor 
for a definition to be true all of its inner tuples/queries must also be true.

\paragraph{A query} is a question to the system that is true if and only if it unifies at least with 
one definition.

\paragraph{Free and bound variables} on the context of a definition all definition variables are considered 
to be bound to the definition, on the context of queries all variables are free.

\paragraph{Metadata} will be used on intermidiate computations steps to track information about \zm\ terms, 
this information may contain bound variables and constrains.

The metadata will be expressed as,
\[
    Q[\text{bound}: v_{0} \ldots v_{n}, \text{constrains}: \ldots ]
\]

Where $Q$ is \zm\ term and inside of $[]$ is the metadata associeted to $Q$, with label bound representing a set of bound variables to $Q$, and constrains representing 
variable constrains.


Bound information is used to rename variables with same name but are not the same.

\paragraph{Variable renaming} its necessary to ensure that distinct variables with same name are not handled as being the same.

ex: 
\[
    (\var{p}\ \var{q})[\text{bound}: p] \unify (\var{p}\ \var{q})[\text{bound}: p\ q]
\]

The first tuple has only $\var{p}$ as bound variable and the second tuple as $\var{p}$ and $\var{q}$ declared as bound variables.
To ensure that this variables keep their meaning, we rename the bound variables like this:

\[
    (\var{p_{0}}\ \var{q})[\text{bound}: p_{0}] \unify (\var{p_{1}}\ \var{q_{1}})[\text{bound}: p_{1}\ q_{1}]
\]

Afther unification we get

\[
    (\var{p_{0}}\ \var{q})[\text{bound}: p_{0}\ p_{1}\ q_{1}, \text{constrains}: p_{0}=p_{1}\ q=q_{1}]
\]



\paragraph{A computation} is done with the following setps:

\begin{enumerate}
    \item $\alpha = \{q \unify p[\text{bound}: v_{0} \ldots v_{n}] :\forall p \in \delta\}$,
    \item $t \in \alpha$, for every subtuple $s$ in $t$ we repeate the computation step as
    \[(\sigma, \delta, s, \alpha)\]
    \item if there is no more sub-tuples to be processed the computation ends.
\end{enumerate}

\section{Computing Examples}

\subsection{Defining a not equal}

\[ 
    (\text{notEqual}\ \var{p}\ \overline{\var{p}})
\] 

Ex:
\[(\sigma, \delta, q, \alpha ) = (\{\text{yellow}, \text{blue}\}, \{(\text{notEqual}\ \var{p}\ \overline{\var{p}})\}, q, \alpha)\]

\begin{enumerate}
\item $q = (\text{notEqual}\ \var{x}\ \var{x})$
\subitem $(\text{notEqual}\ \var{x}\ \var{x}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})[\text{bound}: p]$
\subitem $(\text{notEqual} \unify \text{notEqual}\ \var{x} \unify \var{p}\ \var{x} \unify \overline{\var{p}})[\text{bound}: p]$ 
\subitem $(\text{notEqual} \unify \text{notEqual}\ \var{x} \unify \var{p}\ \var{x} \unify \overline{\var{p}})[\text{bound}: p]$ 
\subitem $(\text{notEqual} \var{x} \var{x})[\text{bound}: p, \text{constrains}: \var{x}=\var{p} \wedge \var{x} \neq \var{p}]$
\subitem variable $x$ cant be equal and not equal to $\var{p}$ at same time,
\subitem query fails to unify with any of the definitions,
\subitem $\alpha=\emptyset$, no awnsers existe for this query.

\item $q = (\text{notEqual}\  \text{yellow}\ \text{yellow})$
\subitem $(\text{notEqual}\ \text{yellow}\ \text{yellow}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})[\text{bound}: p]$
\subitem $(\text{notEqual} \unify \text{notEqual}\ \text{yellow} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})[\text{bound}: p]$ 
\subitem $(\text{notEqual} \text{yellow} \text{yellow})[\text{bound}: p, \text{constrains}: \text{yellow}=\var{p} \wedge \text{yellow} \neq \var{p}]$
\subitem variable $p$ cant be equal and not equal to $\text{yellow}$ vablue at same time,
\subitem query fails to unify with any of the definitions,
\subitem $\alpha=\emptyset$, no awnsers existe for this query.

\item $q = (\text{notEqual}\  \text{blue}\ \text{yellow})$

\subitem $(\text{notEqual}\ \text{blue}\ \text{yellow}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})[\text{bound}: p]$
\subitem $(\text{notEqual} \unify \text{notEqual}\ \text{blue} \unify \var{p}\ \text{yellow} \unify \overline{\var{p}})[\text{bound}: p]$ 
\subitem $(\text{notEqual} \text{blue} \text{yellow})[\text{bound}: p, \text{constrains}: \text{blue}=\var{p} \wedge \text{yellow} \neq \var{p} \wedge \text{blue} \neq \text{yellow}]$
\subitem $\alpha=\{(\text{notEqual}\  \text{blue}\ \text{yellow})\}$.

\item $q = (\text{notEqual}\ \var{p}\ \text{yellow})$

\subitem $(\text{notEqual}\ \var{p}\ \text{yellow}) \unify (\text{notEqual}\ \var{p}\ \overline{\var{p}})[\text{bound}: p]$
\subitem rename bound variable, $p \rightarrow x$, 
\subitem $(\text{notEqual}\ \var{p}\ \text{yellow}) \unify (\text{notEqual}\ \var{x}\ \overline{\var{x}})[\text{bound}: x]$
\subitem $(\text{notEqual} \unify \text{notEqual}\ \var{p} \unify \var{x}\ \text{yellow} \unify \overline{\var{x}})[\text{bound}: x]$ 
\subitem $(\text{notEqual} \text{p} \text{yellow})[\text{bound}: x, \text{constrains}: \text{p}=\var{x} \wedge \text{yellow} \neq \var{x}]$
\subitem $\alpha=\{(\text{notEqual}\  \var{p}\ \text{yellow})[\text{constrains}: \var{p} \neq \text{yellow}]\}$.

\end{enumerate}

\subsection{Defining a list}

\begin{enumerate}
\item $(\text{list})$
\item $(\text{list}\ \var{item}\ (\text{list}))$
\item $(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$
\end{enumerate}

Ex:
\[
    (\sigma, \delta, q, \alpha ) = (\{\text{yellow}, \text{blue}\}, 
    \{
(\text{list}),
(\text{list}\ \var{item}\ (\text{list})),
(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))
    \}, q, \alpha)
\]

\begin{enumerate}
\item $q = (\text{list})$, query a empty list.
\subitem $(\text{list}) \unify (\text{list}) = (\text{list})$
\subitem all other definitions fail to unify because the number of elements in remainding defintions dont match query tuple.
\subitem $\alpha = {(\text{list})}$
\item $q = (\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list})))$
\subitem Starting with defintion $\text{list}$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list})$, fail.
\subitem Next defintion $(\text{list}\ \var{item}\ (\text{list}))$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list}\ \var{item}\ (\text{list}))[\text{bound}: \text{item} ]$
\subitem $(\text{list} \unify \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}))[\text{bound}: \text{item}]$
\subitem fail to unify $(list)$ with $(\text{list}\ \text{blue}\ (\text{list}))$.
\subitem Next defintion $(\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$,
\subitem $(\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \unify (\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))[\text{bound}: \text{item}\ \text{i}\ \text{tail}]$
\subitem $(\text{list}\unify \text{list}\ \text{yellow} \unify \var{item}\ (\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{i}\ \var{tail}))[\text{bound}: \text{item}\ \text{i}\ \text{tail}]$
\subitem $(\text{list}\ \text{yellow} (\text{list}\unify \text{list}\ \text{blue} \unify \var{i}\ (\text{list}) \unify \var{tail}))[\text{bound}: \text{item}\ \text{i}\ \text{tail}, \text{constrains}: \var{item} = \text{yellow}]$
\subitem $(\text{list}\ \text{yellow} (\text{list}\ \text{blue}\ (\text{list})))
[\text{bound}: \text{item}\ \text{i}\ \text{tail}, \text{constrains}: \var{item} = \text{yellow}\ \var{i}=\text{blue}\ \var{tail}=(\text{list})]$
\subitem the next step is to unify all sub-tuples that are not yet checked with definitions, this are: $(\text{list}\ \text{blue}\ (\text{list}))$ and $(\text{list}))$,
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (list)$, fail.
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{item}\ (\text{list}))[\text{bound}: item]$
\subitem $(\text{list}\unify \text{list}\ \text{blue}\unify \var{item}\ (\text{list}) \unify (\text{list}))[\text{bound}: item]$
\subitem $(\text{list} \text{blue} (\text{list})))[\text{bound}: item, \text{constrains}: \var{item}=\text{blue}]$, succed.
\subitem $(\text{list}\ \text{blue}\ (\text{list})) \unify (\text{list}\ \var{item}\ (\text{list}\ \var{i}\ \var{tail}))$, fail.
\subitem Finally $(list)$ will only unify with $(list)$ definition, ending the process and resulting on $\alpha = \{ (\text{list}\ \text{yellow}\ (\text{list}\ \text{blue}\ (\text{list}))) \}$
\end{enumerate}

\subsection{What john likes?}

A simple example of queryng facts.

We start with the definitions/facts:
\begin{enumerate}

\item $(\text{mary}\ \text{likes}\ \text{wine}\ \var{p})$
\subitem mary likes wine.

\item $(\text{mary}\ \text{likes}\ \text{john}\ \var{p})$
\subitem mary likes john.

\item $(\text{peter}\ \text{likes}\ \text{peter}\ \var{p})$
\subitem peter likes himself.

\item $(\text{john}\ \text{likes}\ \var{stuff}\ (\text{mary}\ \text{likes}\ \var{stuff}\ \var{p}))$
\subitem john likes everything that mary likes.

\item $(\text{john}\ \text{likes}\ \var{stuff}\ (\text{mary}\ \text{likes}\ \var{stuff}\ \var{p}))$
\subitem john likes everything that mary likes.

\item $(\text{john}\ \text{likes}\ \var{person}\ (\var{person}\ \text{likes}\ \text{wine}\ \var{p}))$
\subitem john likes anyone that likes wine.

\item \[
    (\text{john}\ \text{likes}\ \var{person}\ (\text{list}\ (\var{person}\ \text{likes}\ \var{person}\ \var{p}) (\text{list}\ (\text{notEqual}\ \var{person} \text{john})\ (\text{list}))))
\]
\subitem john likes anyone that likes themselves.

\end{enumerate}


\section{Contributors}
\label{sec:contributors}

\begin{itemize}
    \item \href{https://github.com/fsvieira}{Filipe Vieira, https://github.com/fsvieira}
\end{itemize}

\end{document}